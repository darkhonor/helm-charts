# Default values for searxng.
namespaceOverride: ""

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: ghcr.io/searxng/searxng
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  create: true
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 977
  runAsGroup: 977
  fsGroup: 977
  fsGroupChangePolicy: "OnRootMismatch"

securityContext:
  runAsNonRoot: true
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsUser: 977
  runAsGroup: 977
  seccompProfile:
    type: RuntimeDefault
  capabilities:
    drop:
    - ALL

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  type: ClusterIP
  port: 8080

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: search.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: search-tls
  #    hosts:
  #      - search.local

# This block is for setting up the HTTPRoute using the Gateway API. More information can be found here: https://gateway-api.sigs.k8s.io/api-types/httproute/
httproute:
  enabled: true
  annotations: {}
    # gateway.networking.k8s.io/route-timeout: "30s"
  gateway:
    enabled: true
    class: "istio"
    listener:
      protocol: "HTTPS"
      port: 443
  hostname: "search.local"
  # If you enable this, you must have cert-manager already installed and an Issuer or ClusterIssuer created
  tls:
    enabled: true
    mode: "Terminate" # Valid Values: Terminate or Passthrough
    certificate:
      generate: true
      algorithm: RSA
      keySize: 4096   # Recommended values are > 2048; NSA Guideline is > 3072 for RSA keys
      duration: 2160h   # Value in Hours that the certificate is good for; chart default is 90 days
      renewBefore: 360h # Value in Hours when the certificate should be renewed before expiration; chart default is 15 days
      organization: ""
    issuer: "" 
    issuerKind: ClusterIssuer   # Value Values: ClusterIssuer or Issuer
  # -- Additional custom labels to add to the HTTPRoute metadata
  # Useful for tagging, selecting, or applying policies to the Ingress via labels.
  extraLabels: {}
  # extraLabels:
  #   app.kubernetes.io/environment: "staging"

networkPolicy:
  enabled: false
  # Traefik Gateway namespace (adjust to your installation)
  gatewayNamespace: "traefik"  # Common: traefik, kube-system, or traefik-system
  # Select Traefik pods specifically (recommended)
  # Find your labels with: kubectl get pods -n traefik --show-labels
  gatewaySelector:
    app.kubernetes.io/name: traefik
    # app.kubernetes.io/instance: traefik  # Uncomment if needed
  # Allow HTTP egress (needed for some search engines)
  allowHTTP: true
  # Additional ingress sources (optional)
  additionalIngressSources: []
  # Additional egress rules (optional)
  additionalEgressRules: []
  # External Valkey configuration (only if valkey.enabled: false)
  externalValkey: []
  #  - namespaceSelector:
  #      matchLabels:
  #        kubernetes.io/metadata.name: database
  #    podSelector:
  #      matchLabels:
  #        app: valkey

# If you have issues with your DNS, you may need to configure the following:
# dns:
#   configure: true
#   policy: None        # Default: ClusterFirst; None is for when you need to fully configure  
#   config:
#     nameservers:
#       - 192.168.0.1   # Network DNS servers
#     searches:
#       - search.local  # Your home DNS Domain
#     options:
#       - name: ndots
#         value: "5"

resources:
  limits:
    cpu: 1000m
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 512Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6

readinessProbe:
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

config:
  # Configure the SearXNG Settings IAW https://docs.searxng.org/admin/settings/index.html
  settings:
    enabled: true
    data: |-
      # see https://docs.searxng.org/admin/settings/settings.html#settings-use-default-settings
      use_default_settings: true

      # See https://docs.searxng.org/admin/settings/settings_server.html
      server:
        secret_key: "changeme"  # REQUIRED: CHANGE THIS VALUE IN YOUR INSTANCE
        limiter: true  # enable this when running the instance for a public usage on the internet
        image_proxy: true
        public_instance: true
        method: "GET" # Alternatives are GET and POST; 
        default_http_headers:
          X-Content-Type-Options : nosniff
          X-Download-Options : noopen
          X-Robots-Tag : noindex, nofollow
          Referrer-Policy : no-referrer

      general:
        instance_name: "HomeLab SearXNG"
        #contact_url: "mailto:your@email.com"
        enable_metrics: true

      # See https://docs.searxng.org/admin/settings/settings_search.html
      search:
        safe_search: 1  # 0: None, 1: Moderate, 2: Strict
        autocomplete: ""  # Leave blank to disable
        languages:
          - en
          - en-US
          - ko
          - ko-KR

      ui:
        default_locale: "en"
        query_in_title: false
        infinite_scroll: false
        center_alignment: false
        cache_url: https://web.archive.org/web/

      valkey:
        url: valkey://searxng-valkey:6379/0

  # Configure according to https://docs.searxng.org/admin/searx.limiter.html
  limiter:
    enabled: true
    data: |-
      [botdetection.ip_limit]
      # activate link_token method in the ip_limit method
      link_token = true

  uwsgi:
    enabled: true
    data: |-
      [uwsgi]
      # Who will run the code
      uid = searxng
      gid = searxng

      # Number of workers (usually CPU count)
      # default value: %k (= number of CPU core, see Dockerfile)
      workers = %k

      # Number of threads per worker
      # default value: 4 (see Dockerfile)
      threads = 4

      # The right granted on the created socket
      chmod-socket = 666

      # Plugin to use and interpreter config
      single-interpreter = true
      master = true
      plugin = python3
      lazy-apps = true
      enable-threads = 4

      # Module to import
      module = searx.webapp

      # Virtualenv and python path
      pythonpath = /usr/local/searxng/
      chdir = /usr/local/searxng/searx/

      # automatically set processes name to something meaningful
      auto-procname = true

      # Disable request logging for privacy
      disable-logging = true
      log-5xx = true

      # Set the max size of a request (request-body excluded)
      buffer-size = 8192

      # No keep alive
      # See https://github.com/searx/searx-docker/issues/24
      add-header = Connection: close

      # uwsgi serves the static files
      static-map = /static=/usr/local/searxng/searx/static
      # expires set to one day
      static-expires = /* 86400
      static-gzip-all = True
      offload-threads = 4

valkey:
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  securityContext:
    runAsNonRoot: true
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsUser: 1000
    runAsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
    capabilities:
      drop:
      - ALL

  # Resource limits/requests for the main Valkey container
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi

  # Persistent storage configuration
  dataStorage:
    # Enable persistent volume claim creation
    enabled: false
    # Use existing PVC by name (skip dynamic provisioning if set)
    persistentVolumeClaimName: ""
    # Name of the volume (referenced in deployment)
    volumeName: "valkey-data"
    # Request size (e.g. 5Gi) for dynamically provisioned volume
    requestedSize: ""
    # Name of the storage class to use
    className: ""
    # Access modes for the PVC (e.g., ReadWriteOnce, ReadWriteMany)
    accessModes:
      - ReadWriteOnce
    # If true, keep the PVC on Helm uninstall
    keepPvc: false
    # Optional annotations to add to the PVC
    annotations: {}
    # Optional labels to add to the PVC
    labels: {}

  # Valkey logging level: debug, verbose, notice, warning
  valkeyLogLevel: "notice"
